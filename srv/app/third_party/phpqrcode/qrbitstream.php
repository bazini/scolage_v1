<?php
/*   __________________________________________________
    |  Obfuscated by YAK Pro - Php Obfuscator  2.0.14  |
    |              on 2024-09-11 13:12:09              |
    |    GitHub: https://github.com/pk-fr/yakpro-po    |
    |__________________________________________________|
*/
/*

*/
 class QRbitstream { public $data = array(); public function size() { return count($this->data); } public function allocate($setLength) { $this->data = array_fill(0, $setLength, 0); return 0; } public static function newFromNum($bits, $num) { goto N5PVn; N5PVn: $bstream = new QRbitstream(); goto pRrWx; QF7Py: $mask = 1 << $bits - 1; goto Zrtfm; pRrWx: $bstream->allocate($bits); goto QF7Py; N3ExI: return $bstream; goto ufhqT; Zrtfm: for ($i = 0; $i < $bits; $i++) { if ($num & $mask) { $bstream->data[$i] = 1; } else { $bstream->data[$i] = 0; } $mask = $mask >> 1; } goto N3ExI; ufhqT: } public static function newFromBytes($size, $data) { goto fvrCU; fvrCU: $bstream = new QRbitstream(); goto j7v1i; W88RW: $p = 0; goto i1wq3; j7v1i: $bstream->allocate($size * 8); goto W88RW; sejHd: return $bstream; goto RCN0_; i1wq3: for ($i = 0; $i < $size; $i++) { $mask = 0x80; for ($j = 0; $j < 8; $j++) { if ($data[$i] & $mask) { $bstream->data[$p] = 1; } else { $bstream->data[$p] = 0; } $p++; $mask = $mask >> 1; } } goto sejHd; RCN0_: } public function append(QRbitstream $arg) { goto rasY_; mqwAM: return 0; goto L_Yot; K5K49: $this->data = array_values(array_merge($this->data, $arg->data)); goto mqwAM; RiA0Z: if ($this->size() == 0) { $this->data = $arg->data; return 0; } goto K5K49; rasY_: if (is_null($arg)) { return -1; } goto Cpj3k; Cpj3k: if ($arg->size() == 0) { return 0; } goto RiA0Z; L_Yot: } public function appendNum($bits, $num) { goto Ncoe8; fPNnE: unset($b); goto w6wLB; qs7ix: $b = QRbitstream::newFromNum($bits, $num); goto sLTr7; sLTr7: if (is_null($b)) { return -1; } goto IRjSu; IRjSu: $ret = $this->append($b); goto fPNnE; w6wLB: return $ret; goto y2sOx; Ncoe8: if ($bits == 0) { return 0; } goto qs7ix; y2sOx: } public function appendBytes($size, $data) { goto e22Df; e22Df: if ($size == 0) { return 0; } goto GOaAx; Becdp: unset($b); goto oRHJG; oRHJG: return $ret; goto EMgIk; uAUJ0: $ret = $this->append($b); goto Becdp; rFMmV: if (is_null($b)) { return -1; } goto uAUJ0; GOaAx: $b = QRbitstream::newFromBytes($size, $data); goto rFMmV; EMgIk: } public function toByte() { goto FFRyr; mrPCo: $p = 0; goto NUPwS; MpW6w: $bytes = (int) ($size / 8); goto mrPCo; NUPwS: for ($i = 0; $i < $bytes; $i++) { $v = 0; for ($j = 0; $j < 8; $j++) { $v = $v << 1; $v |= $this->data[$p]; $p++; } $data[$i] = $v; } goto cF6pk; a9SNy: return $data; goto DZQw7; l5dfA: if ($size == 0) { return array(); } goto sCAlI; cF6pk: if ($size & 7) { goto FBH9g; FBH9g: $v = 0; goto hyrHW; bZzsK: $data[$bytes] = $v; goto bg1l_; hyrHW: for ($j = 0; $j < ($size & 7); $j++) { $v = $v << 1; $v |= $this->data[$p]; $p++; } goto bZzsK; bg1l_: } goto a9SNy; sCAlI: $data = array_fill(0, (int) (($size + 7) / 8), 0); goto MpW6w; FFRyr: $size = $this->size(); goto l5dfA; DZQw7: } }

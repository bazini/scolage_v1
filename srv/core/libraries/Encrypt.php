<?php
/*   __________________________________________________
    |  Obfuscated by YAK Pro - Php Obfuscator  2.0.14  |
    |              on 2024-09-11 13:11:16              |
    |    GitHub: https://github.com/pk-fr/yakpro-po    |
    |__________________________________________________|
*/
/*

*/
 defined("\x42\x41\123\105\120\x41\124\110") or exit("\116\157\x20\144\151\x72\x65\143\164\x20\x73\143\162\x69\x70\x74\40\141\x63\143\x65\163\x73\x20\x61\154\154\x6f\167\145\144"); class CI_Encrypt { public $encryption_key = ''; protected $_hash_type = "\x73\x68\141\61"; protected $_mcrypt_exists = FALSE; protected $_mcrypt_cipher; protected $_mcrypt_mode; public function __construct() { if (($this->_mcrypt_exists = function_exists("\x6d\x63\162\x79\x70\x74\x5f\145\156\x63\x72\171\x70\164")) === FALSE) { show_error("\124\x68\145\40\105\x6e\143\162\171\160\164\40\x6c\x69\142\x72\x61\162\x79\40\162\145\161\165\x69\x72\145\x73\x20\164\x68\145\40\115\143\162\x79\x70\x74\40\145\170\x74\145\156\x73\x69\x6f\156\56"); } log_message("\x69\x6e\146\157", "\x45\x6e\143\x72\171\x70\164\40\103\x6c\x61\163\x73\40\x49\x6e\151\x74\x69\x61\154\x69\172\145\x64"); } public function get_key($key = '') { if ($key === '') { goto BUTKK; BUTKK: if ($this->encryption_key !== '') { return $this->encryption_key; } goto e0Efm; e0Efm: $key = config_item("\x65\156\143\162\171\x70\164\151\x6f\156\x5f\153\145\171"); goto gdLcw; gdLcw: if (!self::strlen($key)) { show_error("\111\x6e\x20\x6f\x72\144\145\x72\x20\x74\157\x20\165\x73\145\40\x74\x68\145\x20\145\x6e\x63\x72\171\x70\164\151\x6f\156\x20\143\154\141\163\163\40\x72\145\x71\165\151\162\x65\x73\40\164\150\x61\x74\x20\171\157\165\x20\x73\145\x74\40\x61\156\40\145\x6e\143\x72\x79\160\164\x69\x6f\156\40\x6b\145\171\40\151\x6e\x20\x79\157\x75\162\40\x63\x6f\x6e\146\151\x67\40\146\x69\154\x65\56"); } goto aPjoq; aPjoq: } return md5($key); } public function set_key($key = '') { $this->encryption_key = $key; return $this; } public function encode($string, $key = '') { return base64_encode($this->mcrypt_encode($string, $this->get_key($key))); } public function decode($string, $key = '') { if (preg_match("\x2f\x5b\136\141\55\x7a\x41\x2d\x5a\60\x2d\71\x5c\57\134\x2b\x3d\135\57", $string) or base64_encode(base64_decode($string)) !== $string) { return FALSE; } return $this->mcrypt_decode(base64_decode($string), $this->get_key($key)); } public function encode_from_legacy($string, $legacy_mode = MCRYPT_MODE_ECB, $key = '') { goto vR9XA; aqAaz: $this->set_mode($current_mode); goto UKjU_; LcTnT: $key = $this->get_key($key); goto L7WKu; vR9XA: if (preg_match("\57\x5b\x5e\x61\55\172\101\x2d\x5a\60\55\71\x5c\x2f\x5c\53\75\135\57", $string)) { return FALSE; } goto KNi8T; zLHpZ: $dec = $this->_xor_decode($dec, $key); goto aqAaz; UKjU_: return base64_encode($this->mcrypt_encode($dec, $key)); goto HoHew; lpNdk: $this->set_mode($legacy_mode); goto LcTnT; KNi8T: $current_mode = $this->_get_mode(); goto lpNdk; L7WKu: $dec = base64_decode($string); goto BVv5Q; BVv5Q: if (($dec = $this->mcrypt_decode($dec, $key)) === FALSE) { $this->set_mode($current_mode); return FALSE; } goto zLHpZ; HoHew: } protected function _xor_decode($string, $key) { goto cDlXC; cDlXC: $string = $this->_xor_merge($string, $key); goto xGgub; FlECE: return $dec; goto etlof; xGgub: $dec = ''; goto etWgu; etWgu: for ($i = 0, $l = self::strlen($string); $i < $l; $i++) { $dec .= $string[$i++] ^ $string[$i]; } goto FlECE; etlof: } protected function _xor_merge($string, $key) { goto E_8Hi; ZeONF: for ($i = 0, $ls = self::strlen($string), $lh = self::strlen($hash); $i < $ls; $i++) { $str .= $string[$i] ^ $hash[$i % $lh]; } goto D9xtT; E_8Hi: $hash = $this->hash($key); goto aoXfP; aoXfP: $str = ''; goto ZeONF; D9xtT: return $str; goto EwM9q; EwM9q: } public function mcrypt_encode($data, $key) { goto nMds7; S3sc3: $init_vect = mcrypt_create_iv($init_size, MCRYPT_DEV_URANDOM); goto V89LH; V89LH: return $this->_add_cipher_noise($init_vect . mcrypt_encrypt($this->_get_cipher(), $key, $data, $this->_get_mode(), $init_vect), $key); goto VwpYv; nMds7: $init_size = mcrypt_get_iv_size($this->_get_cipher(), $this->_get_mode()); goto S3sc3; VwpYv: } public function mcrypt_decode($data, $key) { goto WBuAH; n6Znt: $init_vect = self::substr($data, 0, $init_size); goto HplxX; kvD6f: return rtrim(mcrypt_decrypt($this->_get_cipher(), $key, $data, $this->_get_mode(), $init_vect), "\0"); goto QXpsJ; HplxX: $data = self::substr($data, $init_size); goto kvD6f; zB0EV: if ($init_size > self::strlen($data)) { return FALSE; } goto n6Znt; zQk8q: $init_size = mcrypt_get_iv_size($this->_get_cipher(), $this->_get_mode()); goto zB0EV; WBuAH: $data = $this->_remove_cipher_noise($data, $key); goto zQk8q; QXpsJ: } protected function _add_cipher_noise($data, $key) { goto hqzCt; lfyQo: $str = ''; goto v9hpz; hqzCt: $key = $this->hash($key); goto lfyQo; I6OnW: return $str; goto rnA56; v9hpz: for ($i = 0, $j = 0, $ld = self::strlen($data), $lk = self::strlen($key); $i < $ld; ++$i, ++$j) { if ($j >= $lk) { $j = 0; } $str .= chr((ord($data[$i]) + ord($key[$j])) % 256); } goto I6OnW; rnA56: } protected function _remove_cipher_noise($data, $key) { goto VZMgX; VZMgX: $key = $this->hash($key); goto PHW46; VN83V: for ($i = 0, $j = 0, $ld = self::strlen($data), $lk = self::strlen($key); $i < $ld; ++$i, ++$j) { if ($j >= $lk) { $j = 0; } $temp = ord($data[$i]) - ord($key[$j]); if ($temp < 0) { $temp += 256; } $str .= chr($temp); } goto gllx4; gllx4: return $str; goto kRGDB; PHW46: $str = ''; goto VN83V; kRGDB: } public function set_cipher($cipher) { $this->_mcrypt_cipher = $cipher; return $this; } public function set_mode($mode) { $this->_mcrypt_mode = $mode; return $this; } protected function _get_cipher() { if ($this->_mcrypt_cipher === NULL) { return $this->_mcrypt_cipher = MCRYPT_RIJNDAEL_256; } return $this->_mcrypt_cipher; } protected function _get_mode() { if ($this->_mcrypt_mode === NULL) { return $this->_mcrypt_mode = MCRYPT_MODE_CBC; } return $this->_mcrypt_mode; } public function set_hash($type = "\x73\150\141\x31") { $this->_hash_type = in_array($type, hash_algos()) ? $type : "\x73\150\141\61"; } public function hash($str) { return hash($this->_hash_type, $str); } protected static function strlen($str) { return defined("\115\x42\x5f\117\126\x45\x52\x4c\117\101\x44\x5f\x53\x54\122\111\x4e\x47") ? mb_strlen($str, "\x38\142\x69\164") : strlen($str); } protected static function substr($str, $start, $length = NULL) { if (defined("\115\102\137\117\126\105\x52\x4c\x4f\x41\104\137\x53\124\x52\x49\116\107")) { isset($length) or $length = $start >= 0 ? self::strlen($str) - $start : -$start; return mb_substr($str, $start, $length, "\70\x62\151\x74"); } return isset($length) ? substr($str, $start, $length) : substr($str, $start); } }
